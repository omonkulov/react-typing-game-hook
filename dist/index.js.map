{"version":3,"file":"index.js","sources":["../src/Actions/reset.ts","../src/Actions/index.ts","../src/index.ts","../src/Actions/setCurrentIndex.ts","../src/Actions/end.ts","../src/Actions/typingInsert.ts","../src/Actions/typingDelete.ts"],"sourcesContent":["import { TypingStateType } from '../index';\n\nexport default (state: TypingStateType): TypingStateType => {\n  let { chars } = state;\n\n  return {\n    ...state,\n    startTime: null,\n    endTime: null,\n    charsState: new Array(chars.length).fill(0),\n    currIndex: -1,\n    currChar: '',\n    correctChar: 0,\n    errorChar: 0,\n    phase: 0,\n  };\n};\n","export enum ActionType {\n  RESET = 'RESET',\n  END = 'END',\n  TYPINGINSERT = 'TYPING/INSERT',\n  TYPINGDELETE = 'TYPING/DELETE',\n  SETCURRENTINDEX = 'SET/CURRENTINDEX',\n}\n\nexport type ActionItemType =\n  | { type: ActionType.RESET; payload?: undefined }\n  | { type: ActionType.END; payload?: undefined }\n  | { type: ActionType.TYPINGDELETE; payload: boolean }\n  | { type: ActionType.TYPINGINSERT; payload: string | null }\n  | { type: ActionType.SETCURRENTINDEX; payload: number };\n\nexport { default as RESET } from './reset';\nexport { default as SETCURRENTINDEX } from './setCurrentIndex';\nexport { default as END } from './end';\nexport { default as TYPINGINSERT } from './typingInsert';\nexport { default as TYPINGDELETE } from './typingDelete';\n","import { Reducer, useReducer, useCallback, useMemo } from 'react';\nimport {\n  RESET,\n  SETCURRENTINDEX,\n  END,\n  TYPINGINSERT,\n  TYPINGDELETE,\n  ActionType,\n  ActionItemType,\n} from './Actions';\n\n/**\n * Constants for different phases.\n * @enum {number}\n */\nexport enum PhaseType {\n  /**\n   * Phase when typing has yet to start.\n   */\n  NotStarted = 0,\n  /**\n   * Phase when typing has started.\n   */\n  Started = 1,\n  /**\n   * Phase when typing has ended.\n   */\n  Ended = 2,\n}\n\n/**\n * Constants for different character states.\n * @enum {number}\n */\nexport enum CharStateType {\n  /**\n   * Character has yet to be determined to be correct or incorrect.\n   */\n  Incomplete = 0,\n  /**\n   * Character is determined to be correct.\n   */\n  Correct = 1,\n  /**\n   * Character is determined to be incorrect.\n   */\n  Incorrect = 2,\n}\n\ntype countErrorTypes = 'everytime' | 'once';\n\nexport interface TypingOptionsType {\n  /**\n   * Move on to the next word when space is inputted, defaults to `true`.\n   */\n  skipCurrentWordOnSpace: boolean;\n  /**\n   * Stay on the current index when the inputted character is wrong, defaults to `false`.\n   */\n  pauseOnError: boolean;\n  /**\n   * With `everytime`, choose to count errors everytime a mistake is made.\n   * With `once`, choose to count errors only once for each mistake made.\n   */\n  countErrors: countErrorTypes;\n}\n\n/**\n * Properties of the typing game hook.\n */\nexport interface TypingStateType extends TypingOptionsType {\n  /**\n   * The inputted string to be used.\n   */\n  chars: string;\n  /**\n   * Array of each character's state in the string.\n   * Each item in the array represents the state of each character in the string.\n   * `0` represents incomplete, `1` represents correct and, `2` represents incorrect.\n   */\n  charsState: CharStateType[];\n  /**\n   * Length of the string used.\n   */\n  length: number;\n  /**\n   * Current index of the character the user have typed till.\n   */\n  currIndex: number;\n  /**\n   * Current character the user have typed till.\n   */\n  currChar: string;\n  /**\n   * Number of correct character the user had typed.\n   */\n  correctChar: number;\n  /**\n   * Number of incorrect character the user had typed.\n   */\n  errorChar: number;\n  /**\n   * Represent the current state.\n   * `0` typing haven't started, `1` typing started, `2` typing ended.\n   */\n  phase: PhaseType;\n  /**\n   * Time in milliseconds when the typing started.\n   */\n  startTime: number | null;\n  /**\n   * Time in milliseconds when the typing ended.\n   */\n  endTime: number | null;\n}\n\n/**\n * Methods of the typing game hook.\n */\nexport interface TypingActionType {\n  /**\n   * Duration in milliseconds since the typing started.\n   * 0 if the typing has yet to start.\n   * When the typing ended, the duration will be equivalent to endTime - startTime.\n   */\n  getDuration: () => number;\n  /**\n   * Reset the typing sequence.\n   */\n  resetTyping: () => void;\n  /**\n   * Ends the typing sequence but not reset it.\n   */\n  endTyping: () => void;\n  /**\n   * Insert a character into the current typing sequence.\n   * @param {string | null} char A character to be inserted.\n   * If falsy or no argument is supplied, skip the current character.\n   */\n  insertTyping: (char?: string) => void;\n  /**\n   * Delete a character from the current typing sequence.\n   * @param {boolean} [deleteWord] If `true`, deletes the whole of the current word. Defaults to `false`.\n   */\n  deleteTyping: (deleteWord?: boolean) => void;\n  /**\n   * Set the current index manually.\n   * @param {number} num Allows from -1 to length - 1 of the text, numbers that falls outside of the range will return a false.\n   */\n  setCurrIndex: (num: number) => boolean;\n}\n\nconst reducer: Reducer<TypingStateType, ActionItemType> = (state, action) => {\n  switch (action.type) {\n    case ActionType.SETCURRENTINDEX:\n      return SETCURRENTINDEX(state, action);\n    case ActionType.RESET:\n      return RESET(state);\n    case ActionType.END:\n      return END(state);\n    case ActionType.TYPINGINSERT:\n      return TYPINGINSERT(state, action);\n    case ActionType.TYPINGDELETE:\n      return TYPINGDELETE(state, action);\n    default: {\n      return state;\n    }\n  }\n};\n\n/**\n * React hook to create typing challenge/game/practice/test.\n * @param {string} text A string of words to be used for the typing sequence.\n * @param {Object} [options] Addition options to customize the functionality of the typing sequence.\n * @param {boolean} [options.skipCurrentWordOnSpace] Move on to the next word when space is inputted, defaults to `true`.\n * @param {boolean} [options.pauseOnError] Stay on the current index when the inputted character is wrong, defaults to `false`.\n * @param {countErrorTypes} [options.countErrors]\n * @returns Returns the state and the actions available for the typing hook.\n */\nconst useTypingGame = (\n  text: string,\n  options: Partial<TypingOptionsType> = {}\n): { states: TypingStateType; actions: TypingActionType } => {\n  const initialState = useMemo<TypingStateType>(\n    () => ({\n      startTime: null,\n      endTime: null,\n      chars: text,\n      charsState: new Array(text.length).fill(0),\n      length: text.length,\n      currIndex: -1,\n      currChar: '',\n      correctChar: 0,\n      errorChar: 0,\n      phase: 0,\n      skipCurrentWordOnSpace: true,\n      pauseOnError: false,\n      countErrors: 'everytime',\n      ...options,\n    }),\n    [options, text]\n  );\n\n  const [states, dispatch] = useReducer<\n    Reducer<TypingStateType, ActionItemType>\n  >(reducer, initialState);\n\n  const getDuration = useCallback<TypingActionType['getDuration']>(() => {\n    switch (states.phase) {\n      case PhaseType.NotStarted: {\n        return 0;\n      }\n      case PhaseType.Started: {\n        return states.startTime ? new Date().getTime() - states.startTime : 0;\n      }\n      case PhaseType.Ended: {\n        return states.startTime && states.endTime\n          ? states.endTime - states.startTime\n          : 0;\n      }\n    }\n  }, [states.phase, states.startTime, states.startTime]);\n\n  const resetTyping = useCallback<TypingActionType['resetTyping']>(\n    () => dispatch({ type: ActionType.RESET }),\n    [dispatch]\n  );\n\n  const endTyping = useCallback<TypingActionType['endTyping']>(\n    () => dispatch({ type: ActionType.END }),\n    [dispatch]\n  );\n\n  const insertTyping = useCallback<TypingActionType['insertTyping']>(\n    (letter: string | undefined) => {\n      const payload = letter ? letter[0] : null;\n      dispatch({\n        type: ActionType.TYPINGINSERT,\n        payload,\n      });\n    },\n    [dispatch]\n  );\n\n  const deleteTyping = useCallback<TypingActionType['deleteTyping']>(\n    (deleteWord = false) => {\n      dispatch({\n        type: ActionType.TYPINGDELETE,\n        payload: deleteWord || false,\n      });\n    },\n    [dispatch]\n  );\n\n  const setCurrIndex = useCallback<TypingActionType['setCurrIndex']>(\n    (num: number) => {\n      if (num < -1 || num >= states.length || states.phase !== 2) {\n        return false;\n      }\n      dispatch({\n        type: ActionType.SETCURRENTINDEX,\n        payload: num,\n      });\n      return true;\n    },\n    [dispatch, states.length, states.phase]\n  );\n\n  return {\n    states,\n    actions: {\n      getDuration,\n      resetTyping,\n      endTyping,\n      insertTyping,\n      deleteTyping,\n      setCurrIndex,\n    },\n  };\n};\n\nexport default useTypingGame;\n","import { ActionItemType } from './index';\nimport { TypingStateType } from '../index';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let { chars, length } = state;\n  let payload = action.payload ?? null;\n  if (\n    payload &&\n    typeof payload === 'number' &&\n    payload >= -1 &&\n    payload < length\n  ) {\n    return { ...state, currIndex: payload, currChar: chars[payload] };\n  } else {\n    return state;\n  }\n};\n","import { TypingStateType } from '../index';\n\nexport default (state: TypingStateType): TypingStateType => ({\n  ...state,\n  phase: 2,\n  endTime: new Date().getTime(),\n});\n","import { ActionItemType } from './index';\nimport { TypingStateType } from '../index';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    startTime,\n    endTime,\n    chars,\n    charsState,\n    length,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    skipCurrentWordOnSpace,\n    pauseOnError,\n    countErrors,\n  } = state;\n  let letter = action.payload ?? null;\n  let newStartTime = startTime;\n  let newEndTime = endTime;\n  if (phase === 2) {\n    return state;\n  }\n\n  if (phase === 0) {\n    phase = 1;\n    newStartTime = new Date().getTime();\n  }\n\n  let newCharsState = [...charsState];\n  if (\n    letter === ' ' &&\n    chars[currIndex + 1] !== ' ' &&\n    skipCurrentWordOnSpace\n  ) {\n    let newIndex = chars.indexOf(letter, currIndex);\n    currIndex = newIndex === -1 ? length - 1 : newIndex;\n  } else {\n    if (letter !== null) {\n      if (chars[currIndex + 1] !== letter) {\n        if (newCharsState[currIndex + 1] == 2) {\n          if (countErrors === 'everytime') {\n            errorChar += 1;\n          }\n        } else {\n          newCharsState[currIndex + 1] = 2;\n          errorChar += 1;\n        }\n        if (!pauseOnError) {\n          currIndex += 1;\n        }\n      } else {\n        if (\n          newCharsState[currIndex + 1] === 2 &&\n          pauseOnError &&\n          countErrors === 'once'\n        ) {\n          errorChar -= 1;\n        }\n        newCharsState[currIndex + 1] = 1;\n        correctChar += 1;\n        currIndex += 1;\n      }\n    } else {\n      currIndex += 1;\n    }\n  }\n\n  if (currIndex >= length - 1) {\n    newEndTime = new Date().getTime();\n    phase = 2;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    charsState: newCharsState,\n    errorChar,\n    correctChar,\n    currIndex,\n    currChar,\n    phase,\n    startTime: newStartTime,\n    endTime: newEndTime,\n  };\n};\n","import { ActionItemType } from './index';\nimport { TypingStateType } from '../index';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    chars,\n    charsState,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    countErrors,\n  } = state;\n  let payload = action.payload ?? null;\n\n  if (phase !== 1 || currIndex === -1) {\n    return state;\n  }\n  let newCharsState = [...charsState];\n  if (payload) {\n    let newIndex = chars.lastIndexOf(' ', currIndex);\n    newIndex = newIndex === -1 ? 0 : newIndex + 1;\n    for (let i = currIndex; i >= newIndex; i--) {\n      if (newCharsState[i] === 1) {\n        correctChar -= 1;\n      } else if (newCharsState[i] === 2) {\n        if (countErrors === 'once') {\n          errorChar -= 1;\n        }\n      }\n      newCharsState[i] = 0;\n    }\n    currIndex = newIndex;\n  } else {\n    if (newCharsState[currIndex] === 1) {\n      correctChar -= 1;\n    } else if (newCharsState[currIndex] === 2) {\n      if (countErrors === 'once') {\n        errorChar -= 1;\n      }\n    }\n    newCharsState[currIndex] = 0;\n  }\n  if (currIndex !== -1) {\n    currIndex -= 1;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    currIndex,\n    currChar,\n    charsState: newCharsState,\n    correctChar,\n    errorChar,\n  };\n};\n"],"names":["ActionType","PhaseType","CharStateType","reducer","state","action","type","SETCURRENTINDEX","chars","length","payload","currIndex","currChar","RESET","startTime","endTime","charsState","Array","fill","correctChar","errorChar","phase","END","Date","getTime","TYPINGINSERT","skipCurrentWordOnSpace","pauseOnError","countErrors","letter","newStartTime","newEndTime","newCharsState","newIndex","indexOf","TYPINGDELETE","lastIndexOf","i","text","options","initialState","useMemo","_a","useReducer","states","dispatch","getDuration","useCallback","NotStarted","Started","Ended","resetTyping","endTyping","insertTyping","deleteTyping","deleteWord","setCurrIndex","num","actions"],"mappings":"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"}